% вторая часть

\section{Разработка приложения}

\subsection{Обзор инструментов разработки}

Для разработки приложения на основании требований, описанных в \ref{trebovaniya}, были выбраны следующие инструменты:

\subsubsection{Python}

Язык программирования Python --- высокоуровневый, интерпретируемый, объектно-ориентированный язык программирования, который широко используется для разработки веб-приложений, научных вычислений, анализа данных, искусственного интеллекта, автоматизации задач и многих других областей. Он отличается простотой синтаксиса и легкостью в обучении, что делает его отличным выбором как для начинающих, так и для опытных программистов. В совокупности с большим набором пользовательских библиотек, python предоставляет мощные инструменты для обработки, анализа и визуализации данных, что делает его идеальным выбором для научных и инженерных проектов. 

В качестве альтернативы Python рассматривался язык R. R предоставляет более широкий спектр функций по обработке и анализу данных, особенно в статистических и биостатистических исследованиях. Однако, набор инструментов для визуализации и создания интерфейса приложений у R более ограничен по сравнению с Python. Именно этот фактор стал решающим в пользу Python, так как визуализация данных и создание удобного пользовательского интерфейса играют важную роль в данном проекте.

\subsubsection{Pandas + NumPy}

NumPy (Numerical Python) --- это библиотека для работы с массивами и матрицами, а также для выполнения математических операций над ними. Преимущество NumPy заключается в эффективности и скорости выполнения операций, что делает её неотъемлемым инструментом для анализа данных, машинного обучения, статистики и других областей, где требуется работа с числовыми данными. NumPy поддерживает различные линейные алгебраические операции, генерацию случайных чисел и другие функции, которые часто необходимы в научных исследованиях и разработке алгоритмов.

Pandas --- это библиотека для анализа данных, построенная на основе NumPy. Она предоставляет высокоуровневые структуры данных и инструменты для работы с табличными и временными рядами данных, что делает её идеальной для обработки, анализа и визуализации данных. С Pandas можно легко выполнять такие операции, как фильтрация, агрегация и преобразование данных, что значительно упрощает процесс анализа.

Совместное использование Pandas и NumPy позволяет эффективно решать широкий спектр задач в области научных исследований, финансового анализа, обработки больших данных и машинного обучения. NumPy обеспечивает высокую производительность при выполнении числовых вычислений, тогда как Pandas предоставляет удобные инструменты для обработки и анализа данных. Вместе эти библиотеки образуют мощный инструмент для решения задач, связанных с анализом и обработкой данных в Python. Это делает их неотъемлемой частью проектируемого приложения, обеспечивая эффективность и точность анализа данных.

%NumPy (Numerical Python) --- это библиотека для работы с массивами и матрицами, а также для выполнения математических операций над ними. Преимущество NumPy заключается в дешевизне операций и скорости работы, что делает ее неотъемлемым инструментом для анализа данных, машинного обучения, статистики и других областей, где требуется работа с табличными данными.

%Pandas --- это библиотека для анализа данных, построенная на основе NumPy. Она предоставляет высокоуровневые структуры данных и инструменты для работы с табличными и временными рядами данных.

%Совместное использование Pandas и NumPy позволяет эффективно решать широкий спектр задач в области научных исследований, финансового анализа, обработки больших данных и машинного обучения. NumPy обеспечивает высокую производительность при выполнении числовых вычислений, тогда как Pandas предоставляет удобные инструменты для обработки и анализа данных. Вместе эти библиотеки образуют мощный инструментарий для решения задач, связанных с анализом и обработкой данных в Python.



%Библиотека Pandas -  программная библиотека на языке Python для обработки и анализа данных. Работа Pandas с данными строится поверх библиотеки NumPy, являющейся инструментом более низкого уровня. Предоставляет специальные структуры данных и операции для манипулирования табличными данными. Преимущество NumPy заключается в дешевизне операций и скорости работы, что делает ее неотъемлемым инструментом для анализа данных, машинного обучения, статистики и других областей, где требуется работа с табличными данными.

%\subsubsection{NumPy}

%Библиотека NumPy предоставляет эффективные контейнеры для
%работы с массивами и матрицами данных. В совокупности с Pandas она широко используется для выполнения математических операций и вычислений в Python.

\subsubsection{SciPy}

SciPy --- библиотека, основанная на расширении NumPy, которая применяется для более сложных научных и инженерных вычислений. SciPy включает модули для оптимизации, интеграции, интерполяции, эвристических алгоритмов, статистики и других задач. SciPy в основном написана на Python и частично на языках C, C++ и Fortran, благодаря чему отличается высокой производительностью и скоростью работы. В рамках разработки приложения в большей степени использовался модуль scipy.stats, который предоставляет обширный функционал для проведения статистических вычислений, таких как тесты гипотез, распределения вероятностей и корреляционный анализ.

Использование SciPy в проектируемом приложении позволило значительно расширить возможности анализа данных, обеспечив точность и надёжность результатов. Высокая производительность библиотеки обеспечивает быстрое выполнение сложных вычислений, что особенно важно при работе с большими объёмами данных.

%SciPy --- библиотека, основанная на расширении NumPy, которая применяется для более сложных научных и инженерных вычислений. SciPy в основном написана на Python и частично на языках C, C++ и Fortran, в связи с чем отличается высокой производительностью и скоростью работы. В рамках разработки приложения использовался модуль scipy.stats, который предоставляет обширный функционал для проведения статистических вычислений.

\subsubsection{Matplotlib+Seaborn}

Библиотеки Matplotlib и Seaborn предоставляют возможности для визуализации данных в Python. Matplotlib является основной библиотекой для создания различных типов графиков, таких как линейные графики, гистограммы, графики рассеяния и другие виды визуализаций. Она позволяет создавать статические, анимированные и интерактивные визуализации, что делает её крайне гибкой и мощной.

Seaborn, построенная на основе Matplotlib, предоставляет более высокоуровневый интерфейс для создания статистических графиков. Она упрощает создание сложных визуализаций и обеспечивает реализацию информативных графиков по умолчанию, что значительно сокращает время на настройку и оформление визуализаций.

В проектируемом приложении использование Matplotlib и Seaborn позволяет создавать наглядные и информативные графики, которые помогают лучше понять данные и представить результаты анализа в удобной форме. Это особенно важно для представления данных пользователям и принятия решений на основе анализа.

%Библиотеки Matplotlib и Seaborn. Эти библиотеки предоставляют возможности для визуализации данных в Python. Matplotlib является основной библиотекой для создания различных типов графиков, в то время как Seaborn предоставляет более высокоуровневый интерфейс для создания статистических графиков.

\subsubsection{PyQt}

PyQt --- набор расширений кроссплатформенного графического фреймворка Qt, выполненный в виде библиотеки Python. Qt — фреймворк для разработки кроссплатформенного программного обеспечения с графическим интерфейсом, написанный на языке программирования C++.

Базовыми элементами графического интерфейса PyQt являются виджеты (Widgets) — основные строительные блоки для создания графических интерфейсов пользователя. PyQt предоставляет широкий ассортимент виджетов, которые можно использовать для построения сложных и функциональных приложений. Виджеты в PyQt охватывают разнообразные элементы, такие как кнопки, текстовые поля, метки, списки и многое другое. 

PyQt использует систему сигналов и слотов для реализации взаимодействия с пользователем. Сигналы используются для уведомления об изменениях состояния, а слоты — для обработки этих изменений. Эта система обеспечивает гибкость и мощность при разработке интерфейсов, позволяя легко управлять событиями и действиями пользователя.

Использование PyQt в проектируемом приложении позволяет создать кроссплатформенный графический интерфейс, который будет работать на различных операционных системах, таких как Windows, macOS и Linux. Это обеспечивает широкую доступность моего приложения и удобство для пользователей.

\subsection{Импорт данных}

На первом этапе разработки приложения необходимо реализовать функционал для импорта входных данных из формата .ods (OpenDocument Spreadsheet). Этот формат используется для хранения данных в виде электронных таблиц и широко поддерживается различными офисными пакетами, такими как LibreOffice и OpenOffice. Пример данных, используемых для демонстрации функционала, представлен на рисунках \ref{fig:ris4}-\ref{fig:ris5}.

\begin{figure}[H]
	\centering
	\includegraphics[width=1\linewidth]{pics/ris4} % изображения хранятся в подкаталоге pics
	\caption{Пример входных данных}
	\label{fig:ris4} % эта метка позволяет ссылаться на рисунок в тексте
\end{figure}

\begin{figure}[H]
	\centering
	\includegraphics[width=1\linewidth]{pics/ris5} % изображения хранятся в подкаталоге pics
	\caption{Пример входных данных}
	\label{fig:ris5} % эта метка позволяет ссылаться на рисунок в тексте
\end{figure}

Как видно из примера, входные данные содержат строки и столбцы с различной информацией, которые затем используются в последующих расчетах и анализе данных. Однако, не все данные, содержащиеся в исходном файле, могут быть непосредственно полезны или необходимы для проектируемого приложения. В связи с этим, для использования в приложении эти данные необходимо предварительно очистить. Очистка данных включает удаление лишних или нерелевантных строк и столбцов, обработку пропущенных значений и приведение данных к стандартному виду, который соответствует требованиям приложения.

Чтение файла из табличных форматов (таких как .xls, .xlsx, .ods) реализовано с помощью метода read\_excel() из библиотеки pandas. Этот метод позволяет легко и быстро загружать данные из электронных таблиц в формате DataFrame, который является основной структурой данных в pandas. DataFrame предоставляет удобные инструменты для манипуляции и анализа данных, что делает его идеальным для нашей задачи. Метод read\_excel() возвращает объект DataFrame, который затем передается в специальный метод очистки данных. Этот метод выполняет различные операции по очистке и преобразованию данных в соответствии с определённым шаблоном входных данных, чтобы подготовить их для последующего использования в расчетах и анализах. 

Фрагмент реализации метода, отвечающего за очистку DataFrame представлен в листинге~\ref{lst:1}. Этот метод включает в себя несколько этапов, таких как удаление ненужных столбцов, заполнение пропущенных значений, преобразование типов данных и другие необходимые преобразования. Очистка данных является важным шагом, так как от её качества зависит точность и надежность последующих анализов и расчетов.

\begin{flushleft}
\needspace{3\baselineskip}
\captionof{Program}{Метод очистки данных} \label{lst:1}
\begin{MyCodes}
def _clear_data(self, df):
	# На текущий момент данные очищаются под конкретный шаблон пробных данных.
	# Делаем срез DataFrame, используем первые 14 столбцов
	df = df.iloc[:,0:14] 
	# Переименовываем столбцы для удобного анализа
	df.rename(columns = {
		"№":"Id1",
		"№ п/п по программе":"Id2",
		"Код  и номер кассеты":"Name",
		"Индекс и номер ПС СУЗ":"Index",
		"Коорд. выгр. яч. акт. зоны ":"Coordinates",
		"Дата":"DateTime",
		"к-во кампаний":"Age",
		"Номер пенала":"IdPenal"}, inplace = True)
	
	for i in range(0, len(df.columns.to_list())):
		column = df.columns.to_list()[i]
		# Заменяем спец. символы
		df.replace({column:"-"}, np.NaN, inplace=True) 
		df.replace({column:"н/н"}, np.NaN, inplace=True)
	
	# Заполняем пропуски и приводим типы
	df["Age"]=df["Age"].fillna(0.0).astype(int)
	df["IdPenal"]=df["IdPenal"].fillna(0.0).astype(int)
	df["Id2"]=df["Id2"].fillna(0.0).astype(int)
	
	...
	
	return penals, penals_id, cassetes

\end{MyCodes}
\end{flushleft}

\subsection{Поиск выбросов}

Поиск выбросов в разрабатываемом приложении реализован в качестве метода у сущности, представляющей выборку. Метод основан на вычислении критического значения для выборки по заданному критерию. После вычисления критического значения объект DataFrame агрегируется по условию. Полученные строки удаляются из исходного DataFramе и производится повторный расчёт критического значения согласно параграфу~\ref{povtor}. 

Фрагмент реализации метода поиска выбросов, связанный с расчётом критических значений представлен в листинге~\ref{lst:check}. Полная реализация данного метода представлена в приложении~\ref{check}.

\begin{flushleft}
\needspace{3\baselineskip}
\captionof{Program}{Фрагмент метода поиска выбросов} \label{lst:check}
\begin{MyCodes}
...

# method_type - аргумент функции, указывающих метод поиска выбросов
if method_type=="IQR":
	# Расчёт параметров для метода "IQR"
	a_q1 = df[criteriums[i]].quantile(q=.25)
	a_q3 = df[criteriums[i]].quantile(q=.75)
	a_IQR = a_q3-a_q1
	
	a_corosion_q1 = df[criteriums[i]].quantile(q=.25)
	a_corosion_q3 = df[criteriums[i]].quantile(q=.75)
	a_corosion_IQR = a_corosion_q3-a_corosion_q1
	
	# Критическое значение для реперных ПД
	a_crit = (a_q3+1.7*a_IQR) 
	# Критическое значение ПК
	a_corosion_crit = (a_corosion_q3+1.7*a_corosion_IQR) 
else:
	# Расчёт параметров для метода "3 сигм"
	a_mean = df[criteriums[i]].mean()
	a_corosion_mean = df["Mn-54"].mean()
	a_std = df[criteriums[i]].std()
	# Критическое значение для реперных ПД
	a_corosion_std = df["Mn-54"].std() 
	a_crit = self.crit_value(a_mean, a_std, len(df))
	 # Критическое значение для ПК
	a_corosion_crit = self.crit_value(a_corosion_mean,
		a_corosion_std, len(df))

# Аггрегируем DataFrame по критическому значению
# В результате получаем таблицу ТВС, 
# у которых аномально высокие активности реперных ПД
crit_df = df[(df[criteriums[i]]>a_crit)].reset_index(drop=True)

# Для ТВС, полученных в crit_df
# проверяется выброс по продуктам коррозии
non_hermetic = crit_df[crit_df["Mn-54"]<a_corosion_crit]
recheck = crit_df[crit_df["Mn-54"]>=a_corosion_crit]

...
\end{MyCodes}
\end{flushleft}

Кроме того, в приведённом листинге для вычисления критического значения по методу "3 сигм"\ используется метод crit\_value, который имеет довольно простую реализацию:

\begin{flushleft}
\needspace{3\baselineskip}
\captionof{Program}{Функция вычисления критического значения, для } \label{lst:сrit_value}
\begin{MyCodes}
	
def crit_value(self, mean, std, n):
	student = {2:12.7, 3:4.3, 4:3.18, 5:2.78, 6:2.57, 7:2.45,
		8:2.36, 9:2.31, 10:2.26}
	
	# Исключаем mean==np.NaN и std==np.Nan
	if (not pd.notna(mean)) or (not pd.notna(std)): return 0
	
	# Возвращаем пороговое значение, выше которого считать выбросом
	return mean+student.get(n,3)*std
	
\end{MyCodes}
\end{flushleft}

В данной реализации используются значения критерия Стьюдента из таблицы~\ref{tab:Student}.

Результатом выполнения метода, представленного в листинге~\ref{lst:check}, являются 3 таблицы:

\begin{itemize}
	\item Таблица негерметичных ТВС, содержит исходные данные о ТВС, а также информацию о радионуклидах, на основании которых предполагается их негерметичность. В таблице представлены данные, которые позволяют быстро идентифицировать проблемные ТВС и радионуклиды, вызывающие подозрения. Таблица включает данные о радионуклидах, на основании которых предполагается негерметичность, что позволяет организовать дополнительные проверки и анализ. 
	
	\item Таблицы ТВС для повторной проверки, В этой таблице содержатся исходные данные о ТВС, которые требуют повторной проверки. Таблица включает данные о радионуклидах, на основании которых предполагается негерметичность, что позволяет организовать дополнительные проверки и анализ. 
	
	\item Таблица расчётных параметров, содержащая информацию о математическом ожидании, среднеквадратическом отклонении и квартилях для каждой выборки данных.
\end{itemize}

\subsection{Пользовательский интерфейс}

Данный раздел содержит описание инструментов и трудностей, с которыми я столкнулся во время разработки приложения, а также примеры реализаций графических элементов, используемых в моём приложении.

\subsubsection{Основные окна приложения}

На основании анализа пользовательского сценария использования, представленного в разделе~\ref{Scenarii} был сделан вывод, что проектируемое приложение будет состоять из четырех окон: двух основных и двух диалоговых:

\begin{itemize}
	\item Диалоговое окно импорта файла
	\item Окно анализа пеналов
	\item Окно анализа выборок
	\item Диалоговое окно с результатами статистических тестов 
\end{itemize}

Это разделение позволяет организовать работу приложения наиболее эффективно и удобно для пользователя. Основные и диалоговые окна предназначены для выполнения различных функций, обеспечивая гибкость и простоту использования.

Разделение функционала между окнами позволяет организовать работу приложения наиболее рационально и удобно для пользователя. Окно анализа выборок было решено сделать самостоятельным окном, а не интегрировать его внутрь другого, чтобы обеспечить возможность параллельной работы и гибкость в анализе данных. При переходе в окно анализа выборок сохраняется возможность выбрать выборки заново без изменения логики работы приложения. Это позволяет пользователю легко переключаться между различными режимами работы и эффективно выполнять необходимые аналитические операции.

\subsubsection{Окно импорта файла}

При открытии файла используется класс QFileDialog, который предоставляет окно выбора файла. Удобство этого класса заключается в том, что имеется возможность установить фильтры на расширения файлов, чтобы не вызывать исключений при попытке открыть файл с расширением, которое не поддерживается. Пример окна для выбора файла представлен на рисунке~\ref{fig:ris7}.

\begin{figure}[H]
	\centering
	\includegraphics[width=1\linewidth]{pics/ris7} % изображения хранятся в подкаталоге pics
	\caption{Окно выбора файла}
	\label{fig:ris7} % эта метка позволяет ссылаться на рисунок в тексте
\end{figure}

\subsubsection{Интеграция Matplotlib в качестве QWidget}

Во время разработки приложения я столкнулся с трудностью интеграции графиков Matplotlib в QWidjet. Проблема заключалась в том, что базовый класс Matplotlib создает для графиков независимые окна. Эта реализация мне не подходила, так как разрабатываемое приложение должно иметь целостный и единый интерфейс, где все элементы интегрированы в одно главное окно.

Изучив документацию библиотеки Matplotlib, был найден класс Figu\-reCanvasQTAgg, который предоставляет backend-реализацию холста Canvas для PyQt. Этот класс позволяет встраивать графики Matplotlib непосредственно в виджеты PyQt, что решает проблему независимых окон и обеспечивает интеграцию графиков в основной интерфейс приложения.

На основе класса FigureCanvasQTAgg я разработал собственный пользовательский виджет для использования в моем приложении. Этот виджет включает все необходимые функции для отображения графиков Matplotlib внутри PyQt-приложения. Реализация пользовательского виджета представлена в листинге~\ref{lst:canvas}

\begin{flushleft}
\needspace{3\baselineskip}
\captionof{Program}{Пользовательский класс, интегрирующий Сanvas в QWidget} \label{lst:canvas}
\begin{MyCodes}
class PlotData(FigureCanvasQTAgg): 
	# Виджет для отрисовки графиков, использующий matplotlib
	def __init__(self, parent=None):
		sns.set(style="whitegrid", context="paper")
		self.fig = plt.figure(figsize=(15, 10))
		self.axes = self.fig.add_subplot(111)
		super(PlotData, self).__init__(self.fig)
	
	def draw_plot(self, df, axe_x="Id1",
			axe_y="I-131", type = "barplot", name=None):
		self.axes.cla()
		# Метод позволяет рисовать разные виды графиков seaborn
		# Выбор типа графика происходит по аргументу type
		getattr(sns,type)(data=df, x=axe_x, y=axe_y, ax=self.axes)
		plt.title(label= name, fontsize=16)
\end{MyCodes}
\end{flushleft}

Кроме реализации холста я использовал класс NavigationToolbar2QT, который предоставляет дополнительные возможности для работы с графиками. Эта панель инструментов включает функции навигации по графику, редактирования легенды, а также экспорт графика в формате изображения. Это значительно улучшает удобство работы с графиками, предоставляя пользователю интуитивно понятные инструменты для взаимодействия с визуализациями. 

Использование FigureCanvasQTAgg и NavigationToolbar2QT позволило мне создать мощный и удобный инструмент для отображения и взаимодействия с графиками Matplotlib в моем PyQt-приложении. На рисунке~\ref{fig:ris8} красной рамкой выделены реализованные мною классы.

\begin{figure}[H]
	\centering
	\includegraphics[width=1\linewidth]{pics/ris8} % изображения хранятся в подкаталоге pics
	\caption{Главное окно приложения}
	\label{fig:ris8} % эта метка позволяет ссылаться на рисунок в тексте
\end{figure}

\subsubsection{Главное окно приложения}

Пример внешнего вида главного окна приложения приведён на рисунке~\ref{fig:ris8}. Это окно реализовано с использованием различных элементов библиотеки Qt, которые позволяют создавать удобный и функциональный интерфейс для пользователя. В главном окне представлены основные элементы управления и отображения данных, обеспечивающие легкость навигации и взаимодействия с приложением. Вот некоторые из них:

\begin{itemize}
	\item QPushButton --- класс, который используется для создания кнопок. Эти кнопки выполняют различные действия, такие как запуск анализа, импорт данных, переход между разными секциями приложения и другие операции. Каждое действие, выполняемое при нажатии кнопки, реализуется через привязку функции действия (слота) к функции изменения состояния (сигнала). Кнопки могут быть снабжены текстовыми метками или иконками для лучшего восприятия.
	\item QLabel --- класс, который позволяет выводить текстовую информацию. Эти метки используются для отображения статических текстов, таких как заголовки секций, описания и инструкции для пользователя. QLabel также может отображать изображения и другие графические элементы.
	\item QComboBox --- класс, который реализует выпадающий список, который позволяет пользователю выбирать один из множества вариантов. Этот элемент интерфейса особенно полезен для настройки параметров приложения, выбора данных для анализа и других действий, требующих выбора из заранее определённого набора значений.
	\item QHBoxLayout --- класс, который используется для горизонтальной разметки виджетов. С его помощью виджеты располагаются в одну строку, что позволяет организовать элементы интерфейса логически и удобно для пользователя. Горизонтальная разметка часто применяется для группировки кнопок или других управляющих элементов.
	
	\item QVBoxLayout --- класс, который позволяет располагать виджеты в вертикальной разметке. Элементы располагаются друг под другом, что удобно для создания списков, форм и других структурированных интерфейсов. Вертикальная разметка помогает упорядочить элементы и сделать интерфейс более читаемым.
\end{itemize}

Кнопки, отвечающие за переход по пеналам, реализованы динамически в зависимости от количества пеналов в исходных данных. Это означает, что при запуске приложения на АЭС с разным количеством пеналов СОДС, количество кнопок автоматически адаптируется к числу пеналов. Такая динамическая генерация кнопок обеспечивает гибкость интерфейса и позволяет легко масштабировать приложение под различные объёмы данных.

\subsubsection{Окно анализа выборок}

Пример реализации окна анализа выборок представлен на рисунке~\ref{fig:ris9}.

\begin{figure}[H]
	\centering
	\includegraphics[width=1\linewidth]{pics/ris9} % изображения хранятся в подкаталоге pics
	\caption{Окно анализа выборок}
	\label{fig:ris9} % эта метка позволяет ссылаться на рисунок в тексте
\end{figure}

Несмотря на схожесть с окном анализа выборок, данное окно имеет более сложную структуру. В частности, класс PlotData, описанный в 4.4.3, после проведения поиска выбросов заменяется на класс QTableWidget, который содержит выходную информацию в табличном виде. Данный функционал реализован с применением класса QStackedWidget, который позволяет отображать только один из нескольких дочерних объектов. Пример табличного вывода представлен на рисунке~\ref{fig:ris14}.

\begin{figure}[H]
	\centering
	\includegraphics[width=1\linewidth]{pics/ris14} % изображения хранятся в подкаталоге pics
	\caption{Представление табличной информации через QTableWidget}
	\label{fig:ris14} % эта метка позволяет ссылаться на рисунок в тексте
\end{figure}

\subsection{Экспорт таблиц}

После проведения необходимого анализа, имеется возможность экспорта таблицы в .ods формат. Необходимость данного функционала обосновывается тем, что полученные данные используются в дальнейшем в рабочем процессе, например при составлении отчётов о проведении КГО. 

Следует заметить, что при анализе данных в ручном режиме устоялась практика структурирования данных по различным листам файла excel. Следовательно, чтобы не нарушать рабочий процесс и обеспечить наиболее простое внедрение моего приложения, требуется их структурировать. 

Ниже описана структура файла, которая представлена в формате сопоставления имени листа и информации, которая хранится в таблице на данном листе:

\begin{itemize}
	\item Исходные данные --- Таблица, содержащая входные данные без изменений.
	\item МПi --- Таблица, содержащая данные для $i$-го пенала.
	\item МПi-j --- Таблица, содержащая результаты анализа $j$-ой выборки для $i$-го пенала. Данная таблица содержит данные для каждой ТВС, расчётные параметры выборки, а также негерметичные ТВС и ТВС, для которых требуется повторная проверка.
\end{itemize}

Пример структуры файла представлен на рисунке~\ref{fig:ris15}.

\begin{figure}[H]
	\centering
	\includegraphics[width=1\linewidth]{pics/ris15} % изображения хранятся в подкаталоге pics
	\caption{Структура выходного файла}
	\label{fig:ris15} % эта метка позволяет ссылаться на рисунок в тексте
\end{figure}

Пример экспортированного файла приведён на рисунке~\ref{fig:ris12}.

\begin{figure}[H]
	\centering
	\includegraphics[width=1\linewidth]{pics/ris12} % изображения хранятся в подкаталоге pics
	\caption{Пример выходного файла}
	\label{fig:ris12} % эта метка позволяет ссылаться на рисунок в тексте
\end{figure}

Реализация метода, отвечающего за экспорт данных, представлена на листинге~\ref{lst:export}. Данный метод относится к сущности, представляющей пенал.

\begin{flushleft}
\needspace{3\baselineskip}
\captionof{Program}{Реализация метода экспорта данных в пенале} \label{lst:export}
\begin{MyCodes}

def export_data(self, filename="output.ods", 
	writer = pd.ExcelWriter(path="output.ods",
	datetime_format='DD-MM-YYYY HH:MM:SS')):
"""
Метод, отвечающий за экспорт данных в пенале
"""
	sheet = "МП%s" % self.id # Генерация имени пенала
	self.data.to_excel(excel_writer = writer, sheet_name = sheet,
		index=False) # Запись всех данных в выборке
	
	# Запись данных для каждой выборки
	for i in range(0, len(self.fragments)):
		sheet = "МП%s-%s" % (self.id, (i+1)) 
		
		# Запись расчётных параметров
		parameters = self.fragments[i].get_parameters_df()
		parameters.to_excel(excel_writer = writer, sheet_name = sheet)
		
		#Запись выборочных данных
		self.fragments[i].df.to_excel(excel_writer = writer,
			sheet_name = sheet, index=False)
		
		if not self.fragments[i].non_hermetic_df.empty:
			df = pd.DataFrame(data = ["Негерметичные ТВС:"])
			df.to_excel(excel_writer=writer,sheet_name=sheet,
				index=False)  
			self.fragments[i].non_hermetic_df.to_excel(
				excel_writer=writer, sheet_name=sheet, index=False)
		if not self.fragments[i].recheck_df.empty:
			df = pd.DataFrame(data = ["ТВС для повторной проверки:"])
			df.to_excel(excel_writer=writer,sheet_name=sheet,
				index=False)
			self.fragments[i].recheck_df.to_excel(
				excel_writer=writer, sheet_name=sheet, index=False)

\end{MyCodes}
\end{flushleft}

%Интеграция графиков Matplotlib в QtWidget